## AREX introduction 

### Background 
For a simple service that is just launched, it can be solved only through routine automated testing and manual work. However, our online core business systems are often complex and often require frequent iterations. How to ensure that after modification The correctness of the original business of the system is more important. 
* Conventional automated testing requires a lot of human resources to prepare test data, scripts, etc., and the coverage is usually not high enough to meet the requirements. 
* In order to ensure the stability of an online system, developers and testers face many challenges: It is difficult to quickly verify locally after the development is completed, and if preliminary problems are found, it is easy to fall into the test->bug->fix->testing Cyclic preparation of test data, automated script writing and maintenance requires a lot of labor costs, and it is difficult to ensure coverage. 
* Writing services are difficult to verify, and tests will generate dirty data, such as our core transaction system, which may be sent to databases, message queues, Redis, etc. Write data, this part of the data is often difficult to verify, and the data generated by the test is also difficult to clean up. 
* Online problems are difficult to reproduce locally, and troubleshooting is difficult

### What is AREX  
AREX solves the problem of regression testing by replicating real online traffic to the test environment for automated regression testing.  
AREX uses java instrument to realize data collection and automatic mocking without code intrusion. The intelligent mocking mechanism makes the test running code focus on the application under test, and does not generate real external interaction (DB writing, calling of other services), It also perfectly supports the testing of writing interfaces (such as core trading systems, inventory systems, etc.).  

API tests supported by AREX include  
* General testing, Postman-like testing, use case setup, execution, result ASSERT, etc.
* Comparison test, send the same request to different interfaces, and compare the differences in the returned results, support non-MOCK test, and also support AREX real data MOCK test
* Playback test, compare test with real production data

#### Principle example
We assume that the application in the production environment will normally respond to the user's request, and use the aop method to input the request and return the result, as well as some snapshot data during the execution process, such as the input parameter and return result of accessing the database, and the input parameter and result of accessing the remote server. Save it. Then send the snapshot data to the test machine (the machine where the code has changed) to complete a playback process. By comparing the data from the database, the data of the background request, and the returned result with the data when the online real request occurs, the differences are found, so as to identify the problem of the system under test.
![](../resource/arexintroduce.jpeg)

* xxxTestCase: The collected data is used as a test case during playback
* xxxMock: During playback, the collected data will be used for Mock instead of real data access
* xxxExpect and xxxReal: After the test, the corresponding data will be verified, and the hidden dangers in the code will be found


#### Technical principle  
In JDK1.5, Java introduced the java.lang.Instrument package, which provides some tools to help developers dynamically modify the Class in the system when the Java program is running, so as to achieve functional enhancement of the original class. Many tools are implemented based on this technology, such as Ali's open source arthas, monitoring tool SkyWalking, etc. AREX's data collection and automatic mocking are also implemented based on this technology.

### Platform advantage

#### Low cost   
No code intrusion, basically no access cost
No need to write test cases, massive online requests can also ensure high coverage
The instrumentation code is simple enough and the performance loss is low

#### Diversity Support  
It supports write verification, database, message queue, Redis data verification, and even verification of in-memory data at runtime, and no dirty data is generated during testing.

#### Test cases run stably  
It supports automatic data collection and Mock of various mainstream technology frameworks, see: arex_java , and supports local time, cache, and accurately restores the data environment during production execution during playback.

#### Fast online problem reproduction  
Support one-click local debugging, which can quickly debug online problems locally

#### safe and stable  
Code isolation also realizes health management, and intelligently reduces or closes the data collection frequency when the system is busy

#### Good functional testing support  
It supports test scripts, and can also simply edit the collected data to realize the test of fixed test point of view, avoiding a large amount of test data preparation

## Technical realization    
We adopted the bytecode modification implemented by the ByteBuddy library, and encountered various challenges in the implementation process.

### Trace pass  
When AREX is collecting data, the same request will collect multiple pieces of data (Request/Response, request responses of other service calls, etc.), we need to connect these data in series, so as to be a complete test case. Our applications often use asynchronous frameworks, and also use a lot of multi-threading, which brings great difficulties to the concatenation of data.

#### Java Executors  
Java and various frameworks provide many thread pool implementations. We need to ensure that Trace data can be correctly passed across threads. First, we modify Runnable/Callable as follows:
```
ableWrapper implements Runnable { 
  private final Runnable runnable; 
  private final TraceTransmitter traceTransmitter;
  private RunnableWrapper(Runnable runnable) { 
    this.runnable = runnable; 
    this.traceTransmitter = TraceTransmitter.create(); 
  }

  @Override public void run() { 
    try (TraceTransmitter tm = traceTransmitter.transmit()) { 
      runnable.run(); 
    } 
  }

  @Override public boolean equals(Object o) { 
    if (this == o) return true; 
    if (o == null || getClass() != o.getClass()) 
      return false;
    RunnableWrapper that = (RunnableWrapper) o; 
    return runnable.equals(that.runnable); 
  }

  @Override public int hashCode() { 
    return runnable.hashCode(); 
  }

  @Override public String toString() { 
    return this.getClass().getName() + " - " + runnable.toString(); 
  }

  public static Runnable get(Runnable runnable) { 
    if (null == runnable || TraceContextManager.get() == null) { 
      return runnable; 
    }

    if (runnable instanceof RunnableWrapper) { 
      return runnable; 
    } 
    return new RunnableWrapper(runnable); 
  }
}
```

Then the code modifies various thread pools, replaces Runnable/Callable, and the Wrapper internally uses TraceTransmitter to ensure the correct delivery of Trace.

#### ForkJoinPool  
ForkJoinPool is used by default for parallel stream processing of CompletableFuture and data sets, and applications of heavy parallel computing are also often used. This is quite different from the conventional thread pool implementation and needs to be processed separately. We modified ForkJoinTask, the task unit of ForkJoinPool. , the implementation of this class is more complex, and it is difficult to handle as simple as Runnable, and in order not to destroy the original class structure (Agent on attach mode does not support modification), instead of adding fields to this class to realize data transfer, a WeakCache is used for data buffering, which can ensure trace transfer between task generation and execution threads.

#### async  
There are many asynchronous frameworks (Reactor, RxJava, etc.) in the Java ecosystem, and there are also many class libraries that provide asynchronous implementations. For example, lettuce provides synchronous/asynchronous access to Redis. Different scenarios often require different solutions. Taking ApacheAsyncClient as an example, a fixed running thread monitors the response and initiates a Callback. We need to ensure that multiple cross-thread traces are passed in the entire process of calling, monitoring, and callback. For the specific implementation, please refer to ApacheAsyncClient.

#### other    
##### Version management  
There are often multiple versions of popular components that are used in different systems at the same time. The implementation methods of different versions may be very different or even incompatible. AREX also provides support for multiple versions (such as Jedis). Correct version for bytecode injection to avoid runtime errors. Bytecode injection is performed during class loading, so we must identify the component versions that the application depends on before these classes are loaded, so as to match the versions during class loading to ensure correct code injection. For some implementations, please refer to VersionMatch .

###### Time Management  
Many business systems are time-sensitive, and different time access often returns different results, so we also implement the time Mock function. Since the playback is executed in parallel, it is inappropriate to modify the machine time of the test machine (and many servers cannot modify the current time), so it is still a Mock of the time implemented at the code level.
During data collection, we recorded the current time for each use case, and during playback, we will proxy the System. .nanoTime implementation) to ensure the accuracy of the time, but there may still be a millisecond gap.

###### local cache  
Various caches may be used in business applications to improve runtime performance. There may be large differences in these data in different environments (data synchronization in multiple environments is often a complex process). These data differences may lead to Completely different execution results. In order to avoid this problem, AREX also supports the collection and Mock function of local cached data. Only some simple configurations are needed to achieve automatic data collection and Mock. Of course, this function can also support various Mock function for in-memory data.

##### Code isolation and interoperability  
For the stability of the system, the framework code of AREX agent is loaded in an independent Class loader, which is not interoperable with the application code. In order to ensure that the injected code can be accessed correctly at runtime, we also simply modified the ClassLoader. , to ensure that the runtime code will be loaded by the correct ClassLoader (think SpringBoot's LaunchedURLClassLoader).
